--
-- Root build.ninja solution file generator
--

local ninja = premake.actions.ninja
local solution = premake.solution
local project = premake5.project
local config = premake5.config
local ninjaVarLevel = 1		-- higher = use more ninja build vars
local toolsetDef = {}
ninja.helpMsg = {}

local function mergeTargets(dest, src)
	for k,v in pairs(src or {}) do
		local v = dest[k] or {}
		dest[k] = concat(v, src[k])
	end
end

--
-- The actual rules & actions to build the solution. Always invoked by the default build.ninja, which contains its dependencies
--
function ninja.generateSolution(sln, scope)
	_p('# %s solution build.ninja autogenerated by Premake', sln.name)
	--_p('#  This file is not designed to be invoked directly, the build.ninja header file specifies the dependencies')
	_p('')
	if not scope:get('__header') then 
		ninja.writeHeader()
		scope:set('__header', true)
	end

	_p('# Solution ' .. sln.name)
	_p('')
		
	local slnTargets = {}
	for _,prj in ipairs(sln.projects) do
		local prjTargets = ninja.generateProject(prj, scope)
		mergeTargets(slnTargets, prjTargets)
	end
	
	_p('# Solution build commands')
	local allTargets = {}
	for cfgName,targets in pairs(slnTargets) do
		local slnCfg = sln.name
		if #cfgName > 0 then
			slnCfg = slnCfg ..'.'..cfgName
		end
		_p('build '..slnCfg..': phony '.. table.concat(targets, ' '))
		table.insert( allTargets, slnCfg )
	end
	_p('')
	scope.alltargets = scope.alltargets or {}
	mergeTargets(scope.alltargets, slnTargets)
end

function ninja.writeFooter(scope)
	-- Write help
	if #ninja.helpMsg > 0 then
		_p('# Ninja help message')
		_p('#######################################')
		_p('')
		local echoNewLine = "\\n$"
		_p('ninjaHelpMsg="$')
		for _,line in ipairs(ninja.helpMsg) do
			_p(line..echoNewLine)
		end
		_p('"')
		_p('build help: exec\n cmd=echo -e $ninjaHelpMsg\n description=\t')
		_p('')		
	end
	
	-- Write the global configuration build targets
	local allTargets = scope.alltargets
	if allTargets then
		_p('# Global configuration build targets')
		_p('#######################################')
		_p('')
		for cfgName,targetList in pairs(allTargets) do
			if #cfgName>0 then
				_p('build '..cfgName..': phony '..table.concat(targetList, ' '))
			end
		end		

		local defaultTarget = allTargets['']
		if defaultTarget then
			_p('default '..table.concat(defaultTarget, ' '))
		end
	end
	_p('')
end

function ninja.generateProject(prj, scope)
	if not prj.isUsage then
		local cfgs = project.getConfigs(prj)
	
		ninja.writeToolsets(cfgs, scope)
		_p('# Project ' .. prj.name)
		_p('##############################')
		_p('')
		return ninja.writeProjectTargets(prj, scope)
	else
		return nil
	end
end

function ninja.writeProjectTargets(prj, scope)

	local filesPerConfig = ninja.getInputFiles(prj)
	
	local cfgs = {}
	local prjTargets = {}

	-- Validate
	for cfg in project.eachconfig(prj) do
		if not cfg.kind then
			error("Malformed project '"..prj.name.."', has no kind specified")
		end 
		if not cfg.toolset then
			error("Malformed project '"..prj.name.."', has no toolset specified for kind "..cfg.kind)
		end
		if not cfg.buildtarget then
			error("Malformed project '"..prj.name.."', toolset "..cfg.toolset.." requires buildtarget but none specified")
		end
	
		table.insert(cfgs, cfg)
	end
	
	-- Compile
	for _,cfg in ipairs(cfgs) do
				
		local toolsetName = cfg.toolset
		local toolset = premake.tools[toolsetName]
		local allLinkInputs = {}
		
		local compileTool = toolset:getCompileTool(cfg)		-- cc or cxx
		local linkTool = toolset:getLinkTool(cfg)			-- ar or link
		
		local compileInputs = compileTool:decorateInputs(cfg, '$out', '$in')
		local compileToolRuleName = toolsetName .. '_' .. compileTool.toolName
		local compileToolDef = scope:get(compileToolRuleName)
		
		local linkToolRuleName = 'phony'
		local linkInputs = {}
		local linkToolDef = {}
		if linkTool then
			linkToolRuleName = toolsetName .. '_' .. linkTool.toolName
			linkInputs = linkTool:decorateInputs(cfg, '$out', '$in')
			linkToolDef = scope:get(linkToolRuleName)
		end
		
		-- See if we need to override any flags
		local compileOverrides = {}
		local linkOverrides = {}
		for k,v in pairs(compileInputs) do
			if type(k) ~= 'number' then
				k = compileToolRuleName .. '_' .. k
				if compileToolDef[k] ~= v then
					compileOverrides[k] = v
				end
			end
		end
		for k,v in pairs(linkInputs) do
			if type(k) ~= 'number' then
				k = linkToolRuleName .. '_' .. k
				if linkToolDef[k] ~= v then
					linkOverrides[k] = v
				end
			end
		end
		
		-- List of all files in this config
		local filesInCfg = filesPerConfig[cfg]
		local srcdirFull = prj.basedir
		local srcdir = string.replace(srcdirFull, ninjaRoot, '$root')
		local objdir = string.replace(cfg.objdir, ninjaRoot, '$root')
		local targetdir = string.replace(cfg.targetdir, ninjaRoot, '$root')
		local cfgname = string.replace(cfg.shortname, '_', '.')
		
		local numFilesToCompile = #(filesInCfg['Compile'] or {}) 
		local verboseComments = numFilesToCompile > 5
					
		-- Generate unique ninja build var names
		local objdirN = objdir
		local targetdirN = targetdir
		local srcdirN = srcdir
		
		if not prj.name:find('/test',1,true) then
			local foundO, foundT, foundS
			objdirN,foundO = scope:set('objdir', objdir)
			if targetdir ~= objdir then
				targetdirN,foundT = scope:set('targetdir_' .. cfgname, targetdir)
			else
				targetdirN = objdirN
				foundT = true
			end
			srcdirN,foundS = scope:set('srcdir', srcdir)
			
			if verboseComments then
				_p('# Compile ' .. prj.name .. ' ['..cfgname..']')
				_p('#------------------------------------')
				_p('')
			end
			if not foundO then _p(objdirN ..'='..objdir); end
			if not foundT then _p(targetdirN..'='..targetdir); end
			if not foundS then _p(srcdirN..'='..srcdir); end
			_p('')
		else
			objdirN = scope:getBest(objdirN)
			targetdirN = scope:getBest(targetdirN)
			srcdirN = scope:getBest(srcdirN)
		end
		local uniqueObjNameSet = {}
		
		objdirN = ninja.escVarName(objdirN)
		targetdirN = ninja.escVarName(targetdirN)
		srcdirN = ninja.escVarName(srcdirN)
		
		-- Compile source -> object files, for all files in the config
		for _,fileName in ipairs(filesInCfg['Compile'] or {}) do
			local sourceFileRel = path.getrelative(srcdirFull, fileName)
			
			-- Check if we can compile the file, and get the object file name
			local outputFile = compileTool:getCompileOutput(cfg, fileName, uniqueObjNameSet)

			-- Write the build rule
			-- I assume that any build specialisation is only per project+configuration, not per file
			if outputFile then
				local outputFullpath = objdirN..'/'..outputFile
			
				_p('build ' .. outputFullpath ..': '.. compileToolRuleName..' '..srcdirN..'/'..sourceFileRel)
				for k,v in pairs(compileOverrides) do
	    			v = scope:getBest(v)
					_p(' ' .. k .. '=' .. v)
				end
				
				table.insert( allLinkInputs, outputFullpath )
			elseif linkTool:isLinkInput(cfg, fileName ) then
				table.insert( allLinkInputs, fileName )
			end
		end
		_p('')
		
		for _,fileFullpath in ipairs(filesInCfg['Copy'] or {}) do
			local fileName = path.getname(fileFullpath)
			
			_p('build ' .. targetdirN..'/'..fileName..' : copy ' .. fileFullpath)
		end
		
		for _,fileFullpath in ipairs(filesInCfg['Embed'] or {}) do
			table.insert( allLinkInputs, fileFullpath )
		end

		-- Implicit dependencies : files which affect the build but aren't included in the direct inputs		
		local implicitDeps = {}
		for _,fileFullpath in ipairs(filesInCfg['ImplicitDependency'] or {}) do
			local fileN = scope:getBest(fileFullpath)
			table.insert( implicitDeps, fileN )
		end
		local libs = Seq:ipairs(cfg.linkAsStatic):concat(Seq:ipairs(cfg.linkAsShared))
			:select(function(v) return scope:getBest(v); end)
		for _,lib in libs:each() do
			if path.containsSlash(lib) then
				table.insert( implicitDeps, lib )
			end
		end
		
		-- Link
		local finalTargetInputs = {}
		local finalTargetN = prj.name.. '.' ..cfgname
		local targetName = ('')..cfg.buildtarget.name
		
		if #allLinkInputs > 0 then
			local linkTargetN = targetdirN..'/'..targetName
		
			if verboseComments then
				_p('# Link ' .. prj.name .. ' ['..cfgname..']')
				_p('#++++++++++++++++++++++++++++++++')
			end
			local buildStr = 'build '..linkTargetN..': '..linkToolRuleName ..' '..table.concat(allLinkInputs, ' ')
			
			local implicitDepStr = ''
			if #implicitDeps > 0 then
				if ninjaVarLevel >= 2 then
					for _,v in ipairs(implicitDeps) do
						local varName,found = scope:getName(v, 'dep')
						if not found then
							_p(varName..'='..v)
						end
						implicitDepStr = implicitDepStr..' '..ninja.escVarName(varName)
					end
				else
					implicitDepStr = table.concat(implicitDeps, ' ')
				end
			 
				buildStr = buildStr .. ' | ' .. implicitDepStr
			end 

			if ninjaVarLevel >= 2 then
				for k,v in pairs(linkOverrides) do
					local varName = scope:getName(v)
					if varName then
						linkOverrides[k] = ninja.escVarName(varName)
					else
		    			local varName,found = scope:set(k, v)
		    			if not found then
							_p(varName.. '=' .. v)
							linkOverrides[k] = ninja.escVarName(varName)
						end
					end
				end
			end
			_p(buildStr)
			for k,v in pairs(linkOverrides) do
				v = scope:getBest(v)
				_p(' ' .. k .. '=' .. v)
			end
			
			table.insert(finalTargetInputs,linkTargetN)
			_p('')
		end
		
		-- Post build commands
		local postbuildNumber = 1
		if cfg.postbuildcommands and #cfg.postbuildcommands > 0 then
			if verboseComments then
				_p('# Post build commands')
			end
			local linkTargetN = targetdirN..'/'..targetName
			local description = nil
			for i,cmd in ipairs(cfg.postbuildcommands) do
			
				if string.sub(cmd,1,1) == '#' then
					description = string.sub(cmd,2)
				else
					-- Generate a unique name to reference this post build command
					local postBuildTarget = finalTargetN..'.postbuild'..tostring(postbuildNumber)
					postbuildNumber = postbuildNumber + 1
					repeat
						local cmd2 = cmd
						cmd = scope:getBest(cmd)
					until #cmd2 == #cmd
					_p('build '..postBuildTarget..' : exec '..table.concat(finalTargetInputs, ' '))
					_p(' cmd='..cmd)
					if description then
					  _p(' description='..description)
					  description=nil
					end
					table.insert(finalTargetInputs, postBuildTarget)
				end 
			end
			_p('')
		end
		
		-- Post build commands v2
		if cfg.buildrule and #cfg.buildrule > 0 then
			if verboseComments then
				_p('# Post build commands')
			end
			local linkTargetN = targetdirN..'/'..targetName
			for i,buildrule in ipairs(cfg.buildrule) do
			
				-- Generate a unique name to reference this post build command
				local postBuildTarget = finalTargetN..'.postbuild'..tostring(postbuildNumber)
				postbuildNumber = postbuildNumber + 1
				local cmd = buildrule.command
				repeat
					local cmd2 = cmd
					cmd = scope:getBest(cmd)
				until #cmd2 == #cmd
				
				_p('build '..postBuildTarget..' : exec '..table.concat(finalTargetInputs, ' '))
				_p(' cmd='..cmd)
				if buildrule.description then
				  _p(' description='..buildrule.description)
				end
				table.insert(finalTargetInputs, postBuildTarget)
			end
			_p('')
		end		
		-- Phony rule to build it all
		_p('build '..finalTargetN..': phony '..table.concat(finalTargetInputs, ' '))
		_p('')
		prjTargets[cfgname] = { finalTargetN }
	end -- for cfgs
	
	if prj.defaultconfiguration and prj.configs[prj.defaultconfiguration] then
		local defaultTarget = prj.name..'.'..prj.defaultconfiguration 
		_p('build '..prj.name..': phony '..defaultTarget)
		_p('')
		prjTargets[''] = { prj.name }
	end
	
	return prjTargets
end


function ninja.writeEnvironment(sln)
	local arch = ""
	
	_p('# Environment settings')
	--_p('tooldir=' .. tooldir)
	_p('arch=' .. arch)
	--_p('osver=' .. osver)
	--_p('compilerVer=' .. compilerVer)
	--_p('solution=' .. solutionName)

end

function ninja.writeHeader()
	_p('root=' .. ninjaRoot)
	_p('rule exec')
	_p(' command=$cmd')
	_p(' description=$description')
	_p('')
	
	--_p('build clean: exec')
	--_p(' cmd=ninja -t clean')
end

--
-- Define any toolsets which are not yet defined
--  Run for each config, for each project
--
function ninja.writeToolsets(cfgs, scope)

	local function _pt(str)
		--toolsetNinjaStr = toolsetNinjaStr .. str .. '\n'
		_p(str)  
	end
	
	for _,cfg in cfgs
		:each() 
	do
		local toolsetName = cfg.toolset or 'icc'
		
        local toolset = premake.tools[toolsetName]
		if not toolset then
			error("Invalid toolset '" .. toolsetName .. "' in config " .. cfg.shortname)
		end
		
		-- Make sure we're outputting dependency files as ninja doesn't work properly without them
		if not config.hasDependencyFileOutput(cfg) then
		  	cfg.flags.CreateDependencyFile = 'CreateDependencyFile'
		  	table.insert(cfg.flags, 'CreateDependencyFile')
		end
		
		for _,tool in Seq:ipairs(toolset.tools)
			:where(function(t) return not scope:get(toolsetName .. '_' .. t.toolName);end)
			:each()
		 do
			local toolName = toolsetName .. '_' .. tool.toolName
			local toolBin = tool:getBinary()
			local toolDef = {}
			scope:set(toolName, toolDef)

			local toolInputs = tool:decorateInputs(cfg, '$out', '$in')
			local depfileName = nil
			if tool:hasDependencyFileOutput(cfg) then
				depfileName = '$out' .. (tool.suffixes['depfileOutput'] or '')
			end
			
		    -- Set up tool vars
		    _pt('# Tool ' .. toolName)
		    
			-- Get nice name for tool bin
			local toolDir = path.getdirectory(toolBin)
			local toolDirN, found = scope:set('tooldir_' .. toolsetName, toolDir)
			if not found then _pt(toolDirN .. ' = ' .. toolDir); end
			toolBin = string.replace(toolBin, toolDir, ninja.escVarName(toolDirN))
		    
		    local toolVars = {}
		    for k,v in pairs(toolInputs) do
		    	
		    	-- Extract variables with names as build variables
		    	if type(k) ~= 'number' then
		    		-- Register build variable
		    		local varName = toolName .. '_'..k
			    	toolDef[varName] = v
			    	table.insert( toolVars, ninja.escVarName(varName) )
			    	
			    	-- Write build variable default value
			    	if v ~= '' then
			    		-- Substitute $root
		    			v = string.replace(v, ninjaRoot, '$root')
			    		
				    	local varName,found = scope:set(varName, v)
				    	if not found then
				    		_pt(varName .. ' = ' .. tostring(v))
				    	end
			    	else
			    		-- keep a record that it's blank
				    	scope:set(varName, v)
			    	end
			    end
			end
			
			for _,v in ipairs(toolInputs) do
		    	-- For numbered parameters, put it directly on to the end of the command line
	    		table.insert( toolVars, v )
		    end
		    
			_pt('rule ' .. toolName)
				local cmdLine = tool:getCommandLine(toolBin, toolVars)
				_pt('  command = ' .. cmdLine )
				if depfileName then
				_pt('  depfile = ' .. depfileName )
				end
				if tool.toolName == 'cc' or tool.toolName == 'cxx' then
					_pt('  description = ' .. tool.toolName.. ' $in')
				else
					_pt('  description = ' .. tool.toolName.. ' $out')
				end
			_pt('')
		end
	end 
end 

--
-- Write out a file which sets build variables & includes, then subninjas to the actual build
--  Have to separate it like this so we can have diamond-shape include patterns
--
function ninja.NOTUSEDgenerateDefaultBuild(sln, buildFilename)
	_p('# %s solution build.ninja autogenerated by Premake', sln.name)
	_p('# Ninja build is available to download at http://martine.github.com/ninja/')
	_p('# Type "ninja help" for usage help')
	_p('')
	--_p('root=' .. ninjaRoot)
	ninja.writeHeader()
	local scope = ninja.newScope(buildFilename)
	
	-- Write toolset
	_p(toolsetNinjaStr)
	toolsetNinjaStr = ''
	
	_p('# Solution includes')
	if sln.includesolution then
		for _,slnName in ipairs(sln.includesolution) do
			local extSln = solution.list[slnName]
			if extSln then
				_p('subninja '..scope:getBest(ninja.getSolutionBuildFilename(extSln)))
			end 
		end
	end
	_p('')
		
	_p('include ' .. scope:getBest(ninja.getSolutionBuildFilename(sln)))
end