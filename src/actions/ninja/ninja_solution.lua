--
-- Root build.ninja solution file generator
--

local ninja = premake.actions.ninja
local solution = premake.solution
local project = premake5.project
local config = premake5.config
local definedTools = {}
local ninjaVarLevel = 1		-- higher = use more ninja build vars

function ninja.generate_solution(sln)
  
	_p('# %s solution build.ninja autogenerated by Premake', sln.name)
	_p('# Ninja build is available to download at http://martine.github.com/ninja/')
	_p('# Type "ninja help" for usage help')
	_p('')
	_p('# Solution ' .. sln.name)
	_p('')
	
	if sln.includesolution then
		for _,slnName in ipairs(sln.includesolution) do
			local extSln = solution.list[slnName]
			if extSln then
				_p('subninja '..ninja.getSolutionBuildFilename(extSln))
			end 
		end
	end
	
	--ninja.writeEnvironment(sln)
	--for _,cfg in sln.getConfigs():each() do
	--	_p('subninja ' .. cfg.objdir .. '/build.ninja')
	--local toolsetNames = Seq:new(solution.toolsets)
	--ninja.writeToolsets(toolset)
	
end

function ninja.generate_project(prj)

	if not prj.isUsage then
		local cfgs = project.getConfigs(prj)
	
		ninja.writeToolsets(cfgs)
		_p('# Project ' .. prj.name)
		_p('##############################')
		_p('')
		ninja.writeTargets(prj)
	end
end

function ninja.writeTargets(prj)

	local filesPerConfig = ninja.getInputFiles(prj)
	
	-- Compile
	for _,cfg in project.getConfigs(prj):each() do
		local toolsetName = cfg.toolset or 'icc'
		local toolset = premake.tools[toolsetName]
		local allLinkInputs = {}
		ninja.globalVars['root'] = ninjaRoot
		
		local compileTool = toolset:getCompileTool(cfg)		-- cc or cxx
		local linkTool = toolset:getLinkTool(cfg)			-- ar or link
		
		local compileInputs = compileTool:decorateInputs(cfg, '$out', '$in')
		local compileToolRuleName = toolsetName .. '_' .. compileTool.toolName
		local compileToolDef = definedTools[compileToolRuleName]
		
		local linkToolRuleName = 'phony'
		local linkInputs = {}
		local linkToolDef = {}
		if linkTool then
			linkToolRuleName = toolsetName .. '_' .. linkTool.toolName
			linkInputs = linkTool:decorateInputs(cfg, '$out', '$in')
			linkToolDef = definedTools[linkToolRuleName]
		end
		
		-- See if we need to override any flags
		local compileOverrides = {}
		local linkOverrides = {}
		for k,v in pairs(compileInputs) do
			if type(k) ~= 'number' then
				k = compileToolRuleName .. '_' .. k
				if compileToolDef[k] ~= v then
					compileOverrides[k] = v
				end
			end
		end
		for k,v in pairs(linkInputs) do
			if type(k) ~= 'number' then
				k = linkToolRuleName .. '_' .. k
				if linkToolDef[k] ~= v then
					linkOverrides[k] = v
				end
			end
		end
		
		-- List of all files in this config
		local filesInCfg = filesPerConfig[cfg]
		local srcdirFull = prj.basedir
		local srcdir = string.replace(srcdirFull, ninjaRoot, '$root')
		local objdir = string.replace(cfg.objdir, ninjaRoot, '$root')
		local targetdir = string.replace(cfg.targetdir, ninjaRoot, '$root')
		local cfgname = string.replace(cfg.shortname, '.', '_')
		
		local numFilesToCompile = #(filesInCfg['Compile'] or {}) 
		local verboseComments = numFilesToCompile > 5
					
		-- Generate unique ninja build var names
		local objdirN = objdir
		local targetdirN = targetdir
		local srcdirN = srcdir
		
		if not prj.name:find('/test',1,true) then
			local foundO, foundT, foundS
			objdirN,foundO = ninja.setGlobalVar('objdir', objdir)
			targetdirN,foundT = ninja.setGlobalVar('targetdir_' .. cfgname, targetdir)
			srcdirN,foundS = ninja.setGlobalVar('srcdir', srcdir)
			
			if verboseComments then
				_p('# Compile ' .. prj.name .. ' ['..cfgname..']')
				_p('#------------------------------------')
				_p('')
			end
			if not foundO then _p(objdirN ..'='..objdir); end
			if not foundT then _p(targetdirN..'='..targetdir); end
			if not foundS then _p(srcdirN..'='..srcdir); end
			_p('')
		else
			objdirN = ninja.getBestGlobalVar(objdirN)
			targetdirN = ninja.getBestGlobalVar(targetdirN)
			srcdirN = ninja.getBestGlobalVar(srcdirN)
		end
		local uniqueObjNameSet = {}
		
		objdirN = ninja.escVarName(objdirN)
		targetdirN = ninja.escVarName(targetdirN)
		srcdirN = ninja.escVarName(srcdirN)
		
		-- Compile source -> object files, for all files in the config
		for _,fileName in ipairs(filesInCfg['Compile'] or {}) do
			local sourceFileRel = path.getrelative(srcdirFull, fileName)
			
			-- Check if we can compile the file, and get the object file name
			local outputFile = compileTool:getCompileOutput(cfg, fileName, uniqueObjNameSet)

			-- Write the build rule
			-- I assume that any build specialisation is only per project+configuration, not per file
			if outputFile then
				local outputFullpath = objdirN..'/'..outputFile
			
				_p('build ' .. outputFullpath ..': '.. compileToolRuleName..' '..srcdirN..'/'..sourceFileRel)
				for k,v in pairs(compileOverrides) do
	    			v = ninja.getBestGlobalVar(v)
					_p(' ' .. k .. '=' .. v)
				end
				
				table.insert( allLinkInputs, outputFullpath )
			elseif linkTool:isLinkInput(cfg, fileName ) then
				table.insert( allLinkInputs, fileName )
			end
		end
		_p('')
		
		for _,fileFullpath in ipairs(filesInCfg['Copy'] or {}) do
			local fileName = path.getname(fileFullpath)
			
			_p('build ' .. targetdirN..'/'..fileName..' : copy ' .. fileFullpath)
		end
		
		for _,fileFullpath in ipairs(filesInCfg['Embed'] or {}) do
			table.insert( allLinkInputs, fileFullpath )
		end

		-- Implicit dependencies : files which affect the build but aren't included in the direct inputs		
		local implicitDeps = {}
		for _,fileFullpath in ipairs(filesInCfg['ImplicitDependency'] or {}) do
			local fileN = ninja.getBestGlobalVar(fileFullpath)
			table.insert( implicitDeps, fileN )
		end
		local libs = Seq:ipairs(cfg.linkAsStatic):concat(Seq:ipairs(cfg.linkAsShared))
			:select(function(v) return ninja.getBestGlobalVar(v); end)
		for _,lib in libs:each() do
			if path.containsSlash(lib) then
				table.insert( implicitDeps, lib )
			end
		end
		
		-- Link
		local finalTargetInputs = {}
		local finalTargetN = prj.name..'_'..cfgname
		local targetName = ('')..cfg.buildtarget.name
		
		if #allLinkInputs > 0 then
			local linkTargetN = targetdirN..'/'..targetName
		
			if verboseComments then
				_p('# Link ' .. prj.name .. ' ['..cfgname..']')
				_p('#++++++++++++++++++++++++++++++++')
			end
			local buildStr = 'build '..linkTargetN..': '..linkToolRuleName ..' '..table.concat(allLinkInputs, ' ')
			
			local implicitDepStr = ''
			if #implicitDeps > 0 then
				if ninjaVarLevel >= 2 then
					for _,v in ipairs(implicitDeps) do
						local varName,found = ninja.getGlobalVar(v, 'dep')
						if not found then
							_p(varName..'='..v)
						end
						implicitDepStr = implicitDepStr..' '..ninja.escVarName(varName)
					end
				else
					implicitDepStr = table.concat(implicitDeps, ' ')
				end
			 
				buildStr = buildStr .. ' | ' .. implicitDepStr
			end 

			if ninjaVarLevel >= 2 then
				for k,v in pairs(linkOverrides) do
					local varName = ninja.getGlobalVar(v)
					if varName then
						linkOverrides[k] = ninja.escVarName(varName)
					else
		    			local varName,found = ninja.setGlobalVar(k, v)
		    			if not found then
							_p(varName.. '=' .. v)
							linkOverrides[k] = ninja.escVarName(varName)
						end
					end
				end
			end
			_p(buildStr)
			for k,v in pairs(linkOverrides) do
				v = ninja.getBestGlobalVar(v)
				_p(' ' .. k .. '=' .. v)
			end
			
			table.insert(finalTargetInputs,linkTargetN)
			_p('')
		end
		
		-- Post build commands
		if cfg.postbuildcommands then
			if verboseComments then
				_p('# Post build commands')
			end
			local linkTargetN = targetdirN..'/'..targetName
			-- Generate a unique name to reference this post build command
			local description = nil
			for i,cmd in ipairs(cfg.postbuildcommands) do
			
				if string.sub(cmd,1,1) == '#' then
					description = string.sub(cmd,2)
				else
					
					local postBuildTarget = finalTargetN..'postbuild'..tostring(i)
					repeat
						local cmd2 = cmd
						cmd = ninja.getBestGlobalVar(cmd)
					until #cmd2 == #cmd
					_p('build '..postBuildTarget..' : exec '..table.concat(finalTargetInputs, ' '))
					_p(' cmd='..cmd)
					if description then
					  _p(' description='..description)
					  description=nil
					end
					table.insert(finalTargetInputs, postBuildTarget)
				end 
			end
			_p('')
		end
		
		-- Phony rule to build it all
		_p('build '..finalTargetN..': phony '..table.concat(finalTargetInputs, ' '))
		_p('')
	end
end


function ninja.writeEnvironment(sln)
	local arch = ""
	
	_p('# Environment settings')
	--_p('tooldir=' .. tooldir)
	_p('arch=' .. arch)
	--_p('osver=' .. osver)
	--_p('compilerVer=' .. compilerVer)
	--_p('solution=' .. solutionName)

end

--
-- Define any toolsets which are not yet defined
--  Run for each config, for each project
--
function ninja.writeToolsets(cfgs)

	for _,cfg in cfgs
		:each() 
	do
		local toolsetName = cfg.toolset or 'icc'
		--definedToolsets[toolsetName] = true
		
        local toolset = premake.tools[toolsetName]
		if not toolset then
			error("Invalid toolset '" .. toolsetName .. "' in config " .. cfg.shortname)
		end
		
		-- Make sure we're outputting dependency files as ninja doesn't work properly without them
		if not config.hasDependencyFileOutput(cfg) then
		  	cfg.flags.CreateDependencyFile = 'CreateDependencyFile'
		  	table.insert(cfg.flags, 'CreateDependencyFile')
		end
		
		for _,tool in Seq:ipairs(toolset.tools)
			:where(function(t) return not definedTools[toolsetName .. '_' .. t.toolName];end)
			:each()
		 do
			local toolName = toolsetName .. '_' .. tool.toolName
			local toolBin = tool:getBinary()
			local toolDef = {}
			definedTools[toolName] = toolDef

			local toolInputs = tool:decorateInputs(cfg, '$out', '$in')
			local depfileName = nil
			if tool:hasDependencyFileOutput(cfg) then
				depfileName = '$out' .. (tool.suffixes['depfileOutput'] or '')
			end
			
		    -- Set up tool vars
		    _p('# Tool ' .. toolName)
		    
			-- Get nice name for tool bin
			local toolDir = path.getdirectory(toolBin)
			local toolDirN, found = ninja.setGlobalVar('tooldir_' .. toolsetName, toolDir)
			if not found then _p(toolDirN .. ' = ' .. toolDir); end
			toolBin = string.replace(toolBin, toolDir, ninja.escVarName(toolDirN))
		    
		    local toolVars = {}
		    for k,v in pairs(toolInputs) do
		    	
		    	-- Extract variables with names as build variables
		    	if type(k) ~= 'number' then
		    		-- Register build variable
		    		local varName = toolName .. '_'..k
			    	toolDef[varName] = v
			    	table.insert( toolVars, ninja.escVarName(varName) )
			    	
			    	-- Write build variable default value
			    	if v ~= '' then
			    		-- Substitute $root
		    			v = string.replace(v, ninjaRoot, '$root')
			    		
				    	local varName,found = ninja.setGlobalVar(varName, v)
				    	if not found then
				    		_p(varName .. ' = ' .. tostring(v))
				    	end
			    	else
			    		-- keep a record that it's blank
				    	ninja.setGlobalVar(varName, v)
			    	end
			    end
			end
			
			for _,v in ipairs(toolInputs) do
		    	-- For numbered parameters, put it directly on to the end of the command line
	    		table.insert( toolVars, v )
		    end
		    
			_p('rule ' .. toolName)
				_p('  command = ' .. tool:getCommandLine(toolBin, toolVars) )
				if depfileName then
				_p('  depfile = ' .. depfileName )
				end
				if tool.toolName == 'cc' or tool.toolName == 'cxx' then
					_p('  description = ' .. tool.toolName.. ' $in')
				else
					_p('  description = ' .. tool.toolName.. ' $out')
				end
			_p('')
		end
	end 
end 
