--
-- Root build.ninja solution file generator
--

local ninja = premake.actions.ninja
local solution = premake.solution
local project = premake5.project
local config = premake5.config
local definedTools = {}
local nextProjectCfgUID = 1				-- number referencing a unique project configuration 

function ninja.generate_solution(sln)
  
	_p('# %s solution build.ninja autogenerated by Premake', sln.name)
	_p('# Ninja build is available to download at http://martine.github.com/ninja/')
	_p('# Type "ninja help" for usage help')
	_p('')
	_p('# Solution ' .. sln.name)
	_p('')
	
	--ninja.writeEnvironment(sln)
	--for _,cfg in sln.getConfigs():each() do
	--	_p('subninja ' .. cfg.objdir .. '/build.ninja')
	--local toolsetNames = Seq:new(solution.toolsets)
	--ninja.writeToolsets(toolset)
	
end

function ninja.generate_project(prj)

	if not prj.isUsage then
		local cfgs = project.getConfigs(prj)
	
		ninja.writeToolsets(cfgs)
		_p('# Project ' .. prj.name)
		_p('##############################')
		_p('')
		ninja.writeTargets(prj)
	end
end

function ninja.writeTargets(prj)

	local filesPerConfig = ninja.getInputFiles(prj)
	local filesInAll = filesPerConfig['']
	
	-- Compile
	for _,cfg in project.getConfigs(prj):each() do
		local toolsetName = cfg.toolset
		local toolset = premake.tools[toolsetName or '']
		local allLinkInputs = {}
		local slnRoot = cfg.solution.basedir or '////'
		
		local compileTool = toolset:getCompileTool(cfg)		-- cc or cxx
		local linkTool = toolset:getLinkTool(cfg)			-- ar or link
		
		local compileInputs = compileTool:decorateInputs(cfg, '$out', '$in')
		local compileToolRuleName = toolsetName .. '_' .. compileTool.toolName
		local compileToolDef = definedTools[compileToolRuleName]
		local linkToolRuleName = toolsetName .. '_' .. linkTool.toolName
		local linkInputs = linkTool:decorateInputs(cfg, '$out', '$in')
		local linkToolDef = definedTools[linkToolRuleName]
		
		-- See if we need to override any flags
		local compileOverrides = {}
		local linkOverrides = {}
		for k,v in pairs(compileInputs) do
			if type(k) ~= 'number' then
				k = compileToolRuleName .. '_' .. k
				if compileToolDef[k] ~= v then
					compileOverrides[k] = v
				end
			end
		end
		for k,v in pairs(linkInputs) do
			if type(k) ~= 'number' then
				k = linkToolRuleName .. '_' .. k
				if linkToolDef[k] ~= v then
					linkOverrides[k] = v
				end
			end
		end
		
		local targetName = cfg.buildtarget.name
		
		-- Assign a unique output directory variable name
		local prjCfgUID = tostring(nextProjectCfgUID)
		nextProjectCfgUID = nextProjectCfgUID + 1
		-- Numbers were easier to read than text
		--prjCfgUID = prj.name..'.'..cfg.shortname
		
		-- List of all files in this config
		local filesInCfg = Seq:new(filesInAll):concat(filesPerConfig[cfg])
		local srcdirFull = prj.basedir
		local srcdir = string.gsub(srcdirFull, slnRoot, '$root')
		local objdir = string.gsub(cfg.objdir, slnRoot, '$root')
		local targetdir = string.gsub(cfg.targetdir, slnRoot, '$root')
		
		-- Generate unique ninja build var names
		local objdirN = ninja.setGlobal('objdir_' .. cfg.shortname, objdir)
		local targetdirN = ninja.setGlobal('targetdir_' .. cfg.shortname, targetdir)
		local srcdirN = ninja.setGlobal('srcdir_' .. cfg.shortname, srcdir)

		_p('# Compile ' .. prj.name .. ' ['..cfg.shortname..']')
		_p('#------------------------------------')
		_p('')
		_p(objdirN ..'='..objdir)
		_p(targetdirN..'='..targetdir)
		_p(srcdirN..'='..srcdir)
		_p('')
		local uniqueObjNameSet = {}
		
		objdirN = ninja.escVarName(objdirN)
		targetdirN = ninja.escVarName(targetdirN)
		srcdirN = ninja.escVarName(srcdirN)
				
		-- Compile source -> object files, for all files in the config
		for _,fileName in filesInCfg:each() do
			local sourceFileRel = path.getrelative(srcdirFull, fileName)
			
			-- Check if we can compile the file, and get the object file name
			local outputFile = compileTool:getCompileOutput(cfg, fileName, uniqueObjNameSet)

			-- Write the build rule
			-- I assume that any build specialisation is only per project+configuration, not per file
			if outputFile then
				local outputFullpath = objdirN..'/'..outputFile
			
				_p('build ' .. outputFullpath ..': '.. compileToolRuleName..' '..srcdirN..'/'..sourceFileRel)
				for k,v in pairs(compileOverrides) do
	    			v = string.gsub(v, slnRoot, '$root')
					_p(' ' .. k .. '=' .. v)
				end
				
				table.insert( allLinkInputs, outputFullpath )
			elseif linkTool:isLinkInput(cfg, fileName ) then
				table.insert( allLinkInputs, fileName )
			end
		end
		_p('')
		
		--local prjRelPath = ninja.esc(project.getrelative(cfg.project, ))
	
		-- Link
		
		if #allLinkInputs > 0 then
			_p('# Link ' .. prj.name .. ' ['..cfg.shortname..']')
			_p('#++++++++++++++++++++++++++++++++')
			_p('build '..targetdirN..'/'..targetName..': '..linkToolRuleName ..' $')
			local allObjFilesStr = '  '..table.concat(allLinkInputs, ' ')
			local libs = Seq:ipairs(cfg.linkAsStatic):concat(Seq:ipairs(cfg.linkAsShared))
				:select(function(v) return string.gsub(v, slnRoot, '$root'); end)

			local implicitDeps = libs:mkstring(' ')
			if #implicitDeps > 0 then
				implicitDeps = ' | ' .. implicitDeps
			end 
			_p(allObjFilesStr .. implicitDeps)
			
			for k,v in pairs(linkOverrides) do
    			v = string.gsub(v, slnRoot, '$root')
				_p(' ' .. k .. '=' .. v)
			end
			_p('')
		end
	end
end


function ninja.writeEnvironment(sln)
	local arch = ""
	
	_p('# Environment settings')
	--_p('tooldir=' .. tooldir)
	_p('arch=' .. arch)
	--_p('osver=' .. osver)
	--_p('compilerVer=' .. compilerVer)
	--_p('solution=' .. solutionName)

end

--
-- Define any toolsets which are not yet defined
--  Run for each config, for each project
--
function ninja.writeToolsets(cfgs)

	for _,cfg in cfgs
		:each() 
	do
		local toolsetName = cfg.toolset or 'gcc'
		local slnRoot = cfg.solution.basedir or '////'
		--definedToolsets[toolsetName] = true
		
        local toolset = premake.tools[toolsetName]
		if not toolset then
			error("Invalid toolset '" .. toolsetName .. "' in config " .. cfg.shortname)
		end
		
		-- Make sure we're outputting dependency files as ninja doesn't work properly without them
		if not config.hasDependencyFileOutput(cfg) then
		  	cfg.flags.CreateDependencyFile = 'CreateDependencyFile'
		  	table.insert(cfg.flags, 'CreateDependencyFile')
		end
		
		for _,tool in Seq:ipairs(toolset.tools)
			:where(function(t) return not definedTools[toolsetName .. '_' .. t.toolName];end)
			:each()
		 do
			local toolName = toolsetName .. '_' .. tool.toolName
			local toolDef = {}
			definedTools[toolName] = toolDef

			local toolInputs = tool:decorateInputs(cfg, '$out', '$in')
			local depfileName = nil
			if tool:hasDependencyFileOutput(cfg) then
				depfileName = '$out' .. (tool.suffixes['depfileOutput'] or '')
			end
			
		    -- Set up tool vars
		    _p('# Tool ' .. toolName)
		    local toolVars = {}
		    for k,v in pairs(toolInputs) do
		    	
		    	-- Extract variables with names as build variables
		    	if type(k) ~= 'number' then
		    		-- Register build variable
		    		local varName = toolName .. '_'..k
			    	toolDef[varName] = v
			    	table.insert( toolVars, ninja.escVarName(varName) )
			    	
			    	-- Write build variable default value
			    	if v ~= '' then
			    		-- Substitute $root
		    			v = string.gsub(v, slnRoot, '$root')
			    		
				    	local varName,found = ninja.setGlobal(varName, v)
				    	if not found then
				    		_p(varName .. ' = ' .. tostring(v))
				    	end
			    	end
			    end
			end
			
			for _,v in ipairs(toolInputs) do
		    	-- For numbered parameters, put it directly on to the end of the command line
	    		table.insert( toolVars, v )
		    end
		    
		    table.insert( toolVars, redirectStderr )
		    
			_p('rule ' .. toolName)
				_p('  command = ' .. tool:getCommandLine(toolVars) )
				if depfileName then
				_p('  depfile = ' .. depfileName )
				end
				if toolName == 'cc' or toolName == 'cxx' then
					_p('  description = ' .. toolName.. ' $in')
				else
					_p('  description = ' .. toolName.. ' $out')
				end
			_p('')
		end
	end 
end 
