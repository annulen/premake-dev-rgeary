--
-- Root build.ninja solution file generator
--

local ninja = premake.actions.ninja
local solution = premake.solution
local project = premake5.project
local config = premake5.config
local definedTools = {}
local nextProjectCfgUID = 1				-- number referencing a unique project configuration 

function ninja.generate_solution(sln)
  
	_p('# %s solution build.ninja autogenerated by Premake', sln.name)
	_p('# Ninja build is available to download at http://martine.github.com/ninja/')
	_p('# Type "ninja help" for usage help')
	_p('')
	_p('# Solution ' .. sln.name)
	_p('')
	
	--ninja.writeEnvironment(sln)
	--for _,cfg in sln.getConfigs():each() do
	--	_p('subninja ' .. cfg.objdir .. '/build.ninja')
	--local toolsetNames = Seq:new(solution.toolsets)
	--ninja.writeToolsets(toolset)
	
end

function ninja.generate_project(prj)

	if not prj.isUsage then
		local cfgs = project.getConfigs(prj)
	
		ninja.writeToolsets(cfgs)
		_p('# Project ' .. prj.name)
		_p('##############################')
		_p('')
		ninja.writeTargets(prj)
	end
end

function ninja.writeTargets(prj)

	local filesPerConfig = ninja.getInputFiles(prj)
	
	-- Compile
	for _,cfg in project.getConfigs(prj):each() do
		local toolsetName = cfg.toolset or 'icc'
		local toolset = premake.tools[toolsetName]
		local allLinkInputs = {}
		local slnRoot = cfg.solution.basedir or '////'
		ninja.globalVars['root'] = slnRoot
		
		local compileTool = toolset:getCompileTool(cfg)		-- cc or cxx
		local linkTool = toolset:getLinkTool(cfg)			-- ar or link
		
		local compileInputs = compileTool:decorateInputs(cfg, '$out', '$in')
		local compileToolRuleName = toolsetName .. '_' .. compileTool.toolName
		local compileToolDef = definedTools[compileToolRuleName]
		local linkToolRuleName = toolsetName .. '_' .. linkTool.toolName
		local linkInputs = linkTool:decorateInputs(cfg, '$out', '$in')
		local linkToolDef = definedTools[linkToolRuleName]
		
		-- See if we need to override any flags
		local compileOverrides = {}
		local linkOverrides = {}
		for k,v in pairs(compileInputs) do
			if type(k) ~= 'number' then
				k = compileToolRuleName .. '_' .. k
				if compileToolDef[k] ~= v then
					compileOverrides[k] = v
				end
			end
		end
		for k,v in pairs(linkInputs) do
			if type(k) ~= 'number' then
				k = linkToolRuleName .. '_' .. k
				if linkToolDef[k] ~= v then
					linkOverrides[k] = v
				end
			end
		end
		
		local targetName = cfg.buildtarget.name
		
		-- List of all files in this config
		local filesInCfg = filesPerConfig[cfg]
		local srcdirFull = prj.basedir
		local srcdir = string.replace(srcdirFull, slnRoot, '$root')
		local objdir = string.replace(cfg.objdir, slnRoot, '$root')
		local targetdir = string.replace(cfg.targetdir, slnRoot, '$root')
		local cfgname = string.replace(cfg.shortname, '.', '_')
		
		-- Generate unique ninja build var names
		local objdirN,foundO = ninja.setGlobalVar('objdir', objdir)
		local targetdirN,foundT = ninja.setGlobalVar('targetdir_' .. cfgname, targetdir)
		local srcdirN,foundS = ninja.setGlobalVar('srcdir', srcdir)

		_p('# Compile ' .. prj.name .. ' ['..cfgname..']')
		_p('#------------------------------------')
		_p('')
		if not foundO then _p(objdirN ..'='..objdir); end
		if not foundT then _p(targetdirN..'='..targetdir); end
		if not foundS then _p(srcdirN..'='..srcdir); end
		_p('')
		local uniqueObjNameSet = {}
		
		objdirN = ninja.escVarName(objdirN)
		targetdirN = ninja.escVarName(targetdirN)
		srcdirN = ninja.escVarName(srcdirN)
				
		-- Compile source -> object files, for all files in the config
		for _,fileName in ipairs(filesInCfg['Compile'] or {}) do
			local sourceFileRel = path.getrelative(srcdirFull, fileName)
			
			-- Check if we can compile the file, and get the object file name
			local outputFile = compileTool:getCompileOutput(cfg, fileName, uniqueObjNameSet)

			-- Write the build rule
			-- I assume that any build specialisation is only per project+configuration, not per file
			if outputFile then
				local outputFullpath = objdirN..'/'..outputFile
			
				_p('build ' .. outputFullpath ..': '.. compileToolRuleName..' '..srcdirN..'/'..sourceFileRel)
				for k,v in pairs(compileOverrides) do
	    			v = ninja.getBestGlobalVar(v)
					_p(' ' .. k .. '=' .. v)
				end
				
				table.insert( allLinkInputs, outputFullpath )
			elseif linkTool:isLinkInput(cfg, fileName ) then
				table.insert( allLinkInputs, fileName )
			end
		end
		_p('')
		
		for _,fileFullpath in ipairs(filesInCfg['Copy'] or {}) do
			local fileName = path.getname(fileFullpath)
			
			_p('build ' .. targetdirN..'/'..fileName..' : copy ' .. fileFullpath)
		end
		
		for _,fileFullpath in ipairs(filesInCfg['Embed'] or {}) do
			table.insert( allLinkInputs, fileFullpath )
		end

		-- Implicit dependencies : files which affect the build but aren't included in the direct inputs		
		local implicitDeps = {}
		for _,fileFullpath in ipairs(filesInCfg['ImplicitDependency'] or {}) do
			local fileN = ninja.getBestGlobalVar(fileFullpath)
			table.insert( implicitDeps, fileN )
		end
		local libs = Seq:ipairs(cfg.linkAsStatic):concat(Seq:ipairs(cfg.linkAsShared))
			:select(function(v) return ninja.getBestGlobalVar(v); end)
		for _,lib in libs:each() do
			table.insert( implicitDeps, lib )
		end
		
		-- Link
		
		if #allLinkInputs > 0 then
			_p('# Link ' .. prj.name .. ' ['..cfgname..']')
			_p('#++++++++++++++++++++++++++++++++')
			_p('build '..targetdirN..'/'..targetName..': '..linkToolRuleName ..' $')
			local allObjFilesStr = '  '..table.concat(allLinkInputs, ' ')

			if #implicitDeps > 0 then
				_p(allObjFilesStr .. ' | ' .. table.concat( implicitDeps, ' '))
			else
				_p(allObjFilesStr)
			end 
			
			for k,v in pairs(linkOverrides) do
    			v = ninja.getBestGlobalVar(v)
				_p(' ' .. k .. '=' .. v)
			end
			_p('')
		end
	end
end


function ninja.writeEnvironment(sln)
	local arch = ""
	
	_p('# Environment settings')
	--_p('tooldir=' .. tooldir)
	_p('arch=' .. arch)
	--_p('osver=' .. osver)
	--_p('compilerVer=' .. compilerVer)
	--_p('solution=' .. solutionName)

end

--
-- Define any toolsets which are not yet defined
--  Run for each config, for each project
--
function ninja.writeToolsets(cfgs)

	for _,cfg in cfgs
		:each() 
	do
		local toolsetName = cfg.toolset or 'icc'
		local slnRoot = cfg.solution.basedir or '////'
		--definedToolsets[toolsetName] = true
		
        local toolset = premake.tools[toolsetName]
		if not toolset then
			error("Invalid toolset '" .. toolsetName .. "' in config " .. cfg.shortname)
		end
		
		-- Make sure we're outputting dependency files as ninja doesn't work properly without them
		if not config.hasDependencyFileOutput(cfg) then
		  	cfg.flags.CreateDependencyFile = 'CreateDependencyFile'
		  	table.insert(cfg.flags, 'CreateDependencyFile')
		end
		
		for _,tool in Seq:ipairs(toolset.tools)
			:where(function(t) return not definedTools[toolsetName .. '_' .. t.toolName];end)
			:each()
		 do
			local toolName = toolsetName .. '_' .. tool.toolName
			local toolBin = tool:getBinary()
			local toolDef = {}
			definedTools[toolName] = toolDef

			local toolInputs = tool:decorateInputs(cfg, '$out', '$in')
			local depfileName = nil
			if tool:hasDependencyFileOutput(cfg) then
				depfileName = '$out' .. (tool.suffixes['depfileOutput'] or '')
			end
			
		    -- Set up tool vars
		    _p('# Tool ' .. toolName)
		    
			-- Get nice name for tool bin
			local toolDir = path.getdirectory(toolBin)
			local toolDirN, found = ninja.setGlobalVar('tooldir_' .. toolsetName, toolDir)
			if not found then _p(toolDirN .. ' = ' .. toolDir); end
			toolBin = string.replace(toolBin, toolDir, ninja.escVarName(toolDirN))
		    
		    local toolVars = {}
		    for k,v in pairs(toolInputs) do
		    	
		    	-- Extract variables with names as build variables
		    	if type(k) ~= 'number' then
		    		-- Register build variable
		    		local varName = toolName .. '_'..k
			    	toolDef[varName] = v
			    	table.insert( toolVars, ninja.escVarName(varName) )
			    	
			    	-- Write build variable default value
			    	if v ~= '' then
			    		-- Substitute $root
		    			v = string.replace(v, slnRoot, '$root')
			    		
				    	local varName,found = ninja.setGlobalVar(varName, v)
				    	if not found then
				    		_p(varName .. ' = ' .. tostring(v))
				    	end
			    	end
			    end
			end
			
			for _,v in ipairs(toolInputs) do
		    	-- For numbered parameters, put it directly on to the end of the command line
	    		table.insert( toolVars, v )
		    end
		    
			_p('rule ' .. toolName)
				_p('  command = ' .. tool:getCommandLine(toolBin, toolVars) )
				if depfileName then
				_p('  depfile = ' .. depfileName )
				end
				if toolName == 'cc' or toolName == 'cxx' then
					_p('  description = ' .. toolName.. ' $in')
				else
					_p('  description = ' .. toolName.. ' $out')
				end
			_p('')
		end
	end 
end 
